# Programmiersprache R

In diesem Kapitel wollen wir R als Programmierspache kennenlernen.

## Variablen definieren

In einem ersten Schritt wollen wir eine Rechnung (einen Wert) in einer Variable speichern.

```{r, echo=T, collapse=T, comment="#>"}
x <- 2*4
```

Unsere Variable mit dem Namen `x` (immer links in der Zeile) wird über den Zuweisungspfeil `<-` (Tastenkürzel: `option` + `-`) mit dem Ergebnis aus `2*4 (8)` definiert.

Zur Kontrolle können wir `x` mit den folgenden Befehlen aufrufen.

```{r, echo=T, collapse=T, comment="#>"}
x
```

Man kann auch gleich bei der Definition der Variablen die Zuweisung in Klammern schreiben und das Resultat wird gleichzeitig in der Konsole angezeigt.

```{r, echo=T, collapse=T, comment="#>"}
(x <- 2*4)
```

**Tipp:** Sollten Sie aus anderen Programmiersprachen schon Kenntnisse mitbringen und `=` als Zuweisungsoperator kennen, empfehlen wir dennoch eindringlich mit `<-` zu arbeiten. Funktionen in R arbeiten bei der Zuweisung von Argumenten mit dem Zuweisungsoperator `=`. Folglich ist die Verwendung von `<-` nicht nur besser zu lesen, sie kann auch Fehler vorbeugen.

### Variablennamen

Eine Variable muss immer einen Namen haben. Sie darf aus Buchstaben, Zahlen und den Zeichen `.` und `_` bestehen. Dennoch muss sie immer mit einem Buchstaben beginnen und darf keine Leerzeichen enthalten.

Um lesbaren und verständlichen Code zu schreiben, gibt es ein paar Konventionen an die man sich halten sollte. Hier gibt es zwei gängige Möglichkeiten und eine ältere Form, um Variablen zu bennen. 

*Die Wahl ist egal, solange man konsequent bei einer Schreibweise bleibt!*

**1. snake_case_variable**

Bei dieser Schreibform werden die einzelnen Worten in einer Variablenbezeichnung durch Unterstriche verbunden und alle Worte kleingeschrieben. 

**2. camelCaseVariable**

Hier wird nur das erste Wort kleingeschrieben und die folgenden mit dem ersten Buchstaben großgeschrieben.

**3. variable.with.perdiods (alt)**

Die kleingeschriebenen Worte werden mit Punkten getrennt.

```{}
# Gute Bezeichnungen
efaKonstrukt1
efa_konstrukt_1

# Schlechte Bezeichnungen
Efa.konstrukt_1
efaKonstrukt_1

# Unmöglich
efa 1
```

## Funktionen  aufrufen

> "Everything that exists is an object. Everything that happens is a function call".
>
>--John Chambers

Objekte haben wir schon in ihrer einfachsten Form als Rechenergebnis kennengelernt. Nun wollen wir uns den Funktionen (function calls) in R zuwenden. 

Unsere Funktion sieht wie folgt aus (ein fiktionales Beispiel):

```{}
functionName(arg1 = Daten, arg2 = option1, arg3)
```

In einem ersten Schritt sehen wir uns an, welchen Namen die Funktion trägt. Unsere Funktion heißt functionName. Wir können leider nicht direkt aus dem Namen erschließen, welche Auswirkung unser *function call* haben wird. In so einem Fall würde ein Blick in `Help` (`?functionName`) sicher Abhilfe schaffen, wenngleich wir in unserem Beispiel leider keine Dokumentation nutzen können. 

So sehen wir uns in einem zweiten Schritt die *Argumente* unserer Funktion an. Wie wir sehen können, besitzt unsere Funktion drei Argumente: `arg1`, `arg2` und `arg3`. Die Argumente werden mit spezifischen Werten über `=` bestückt. In unserem Beispiel benötigt das erste Argument Daten und das zweite Argument einen spezifischen Wert aus einer Auswahl an möglichen Werten - diese werden immer vom Entwickler der Funktion in der Dokumentation angegeben. Das dritte Argument wird als "default" abgerufen, also über eine Voreinstellung der Entwicklers geladen. Argumente die mit "default" arbeiten sind aber keinesfalls fest. Sie können immer auch durch andere Werte ersetzt werden. Argumente arbeiten immer dann mit "default", wenn die Grundeinstellung des Arguments die häufigste Nutzungsform ist und man nicht bei jedem *function call* die Wertzuweisung von neuem machen möchte. 

**Tipp:** Wollen wir alle verfügbaren Argumente in einer Funktion sehen, drücken wir `Tab`.

**Wichtig!** Eine Funktion kann beliebig viele Argumente besitzen.

Um uns einer "großen" Funktion zu nähern, müssen wir zu Beginn einige "Grundfunktionen" kennenlernen.

* `c()` > Combine: kreiert einen Vektor (Zahlenfolge)
* `seq(from, to, by)` > Generiert eine Sequenz an Zahlen
* `:` > Colon Operator: generiert eine reguläre Sequenz (Sequenz in Einerschritten)
* `rep(x, times, each)` > Wiederholt x 
                          times: Sequent wird n-mal widerholt
                          each: jedes Element wird n-mal wiederholt
* `head(x, n = 6)` > Zeigt die n ersten Elemente von x an
* `tail(x, n = 6)` > Zeigt die n letzten Elemente von x an
* `print(x)` > Gibt Werte eines Objekts aus (vor allem bei großen Objekten wichtig)
* `round(x, digits)` > Rundung von Zahlen

z.B.

```{r, echo=T, collapse=T, comment="#>"}
c(1, 2, 3, 4, 5)

seq(from = 1, to = 10, by = 2)

1:5

rep(x = 2, times = 5, each = 3)

x <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

head(x = x, n = 6)

tail(x = x, n = 4)

print(x = x)

y <- c(1.222, 2.333, 3.444)

round(x = y, digits = 1)
```

Wir wollen uns die Variable `y` etwas genauer ansehen. y enthält durch das Aufrufen der Funktion `c()` eine Reihe von Zahlen (1.222 bis 3.444) mit drei Nachkommastellen. Diese Zahlen wollen wir mit der Funktion `round()` auf eine Nachkommastelle runden. Das Argument `digits` beschreibt damit die Rundungszahl nach dem Komma. `digits = 1` löst eine Rundung der Nachkommastellen auf dei erste Nachkommastelle aus. Der Wert im Argument `digits` kann damit theoretisch von 0 bis ∞ variieren. 

### Verschachtelung von Funktionen

Zudem können wir beliebig viele Funktion ineinander verschachteln, d.h. wir können den Output einer Funktion einer anderen Funktion als Input übergeben. 

Wir bilden zuerst einen Vektor, runden die Zahlen und lassen uns dann nur die ersten drei Zahlen ausgeben.

```{r, echo=T, collapse=T, comment="#>"}
# Mehrere Funktionen hintereinander
x <- c(1.11, 1.22, 1.33, 1.44, 1.55)
x <- round(x = x, digits = 1)
head(x = x, n = 3)

# jetzt in einer verschachtelten Funktion
head(x = round(x = c(1.11, 1.22, 1.33, 1.44, 1.55), digits = 1), n = 3)

# kürzeste Form
head(round(c(1.11, 1.22, 1.33, 1.44, 1.55), digits = 1), n = 3)
```

Die Funktionen werden immer in Reihenfolge *von innen nach außen* ausgeführt. In unserem Beispiel also erst `c()`, dann `round()` und dann `head()`. Jede Funktion gibt ihren Wert an die nächste Funktion weiter. 

**Anmerkung:** Die Funktion `head()` enthält zwei Argumente mit "default"-Werten: keepnums und addrownums. Beide bekommen automatisch den Wert `NULL` und müssen damit nicht ausgeschrieben werden. Sie werden für unsere Anwendung auch nicht gebraucht und damit nicht angepasst. 

Vorteile von verschachtelten Funktionen:

* Es können unendlich viele Funktionen verschachtelt werden. 
* Wir müssen Argumente nicht ausschreiben, solange sie eindeutig von der Funktion erkannt werden können. So gibt es in allen genutzten Funktionen mit `x =` nur eine Schnittstelle für die Dateneingabe. 
* Weiterhin können wir so unseren Code in eine Kette von Befehlen verwandeln, die nur einen Output (ein Objekt) ausgibt. Die Objektstruktur wird damit übersichtlicher. 

Nachteil:

* Wenn wir mehrere Funktionen ineinander verschachteln, kann unser Code schnell unlesbar werden. Natürlich könnten wir die einzelnen Zwischenschritte speichern, wie im Beispiel weiter oben, aber dann definieren wir eine Menge Variablen, welche wir vielleicht gar nicht benötigen.

*Wir werden im Kapitel über Datentransformation einen neuen Operator kennenlernen, welcher eine sehr elegante Lösung für dieses Problem bietet.*

## Objekte und Datentypen 

In R kann alles als Objekt in Variablen gespeichert werden.

* Einzelne Werte / Mehrere Werte (z.B. ein Datensatz mit Rohdaten)
* Tabellen
* Statistische Modelle
* Ergebnisse statitischer Analysen
* Funktionen, etc. 

Anmerkung: Objekte sind nicht gleich Variablen, da Objekte nicht gespeichert werden *müssen*. Ein Objekt wird erst dann zur Variable, wenn es eine Bezeichnung über `<-` erhält und damit gespeichert wird. Die Zahlenfolge aus `c(1, 2, 3)` stellt auch schon ein Objekt da.

In R gibt es eine Vielzahl von verschiedenen Objekttypen. Die grundlegenden Objekttypen sind:

### Vektoren (vector)

* Vektoren → ordinale/metrische Variablen
  * numeric (Zahlen)
  * character (Buchstaben)
  * logical (Richtig oder Falsch)
  
Beispiel

```{r, echo=T, collapse=T, comment="#>"}
# Numerischer Verktor (numeric vector) 
x <- c(1, 2, 3, 4, 5) 
x

# Buchstaben Vektor (character vector) 
y <- c("Peter", "Yusuf", "Sarah", "Aayana")
y

# Logischer Vektor (logical vector)
z <- c(TRUE, FALSE, NA) 
z
```

**Tipp:** TRUE bzw. FALSE können mit T bzw. F abgekürzt werden.

Vektoren stellen die fundamentalen Datentypen dar. Alle weiteren Datentypen bauen auf diesen auf. 

**Wichtig!** Vektoren müssen aus denselben Elementen bestehen, d.h. wir können nicht logical und character Vektoren mischen. Sie bilden damit die `atomare Struktur` in R.

* **numeric vector:** Die häufigste Datenform in R. Numerische Vektoren lassen sich zudem weiter unterteilen, in `integer` (ganze Zahlen) und `double` (reele Zahlen - Kommazahlen). Zahlen werden in R praktisch immer als `double` abgelegt (auch die ganzen Zahlen) und müssen somit nie für Berechungen gewandelt werden. 

* **character vector:** Die Elemente dieses Typs bestehen aus Zeichen, welche von Anführungszeichen umgeben werden (entweder ' oder " ). Sie werden auch *strings* genannt.

  Anmerkung: Anführungszeichen dienen in R zur Kennzeichnung von nicht numerischen Werten. Wir müssen also alle Worte in jedem Kontext in Anführungszeichen schreiben.

* **logical vector:** Die Elemente dieses Typs können nur 3 Werte annehmen:`TRUE`, `FALSE` oder `NA`. Logische Vektoren lassen sich auch numerisch übersetzen in `TRUE = 1` und `FALSE = 0`, damit werden sie auch als `integer` abgelegt. Das wird vor allem bei der Datenselektion relevant.

  Anmerkung: `NA` steht für fehlende Werte.

Vektoren haben folgend drei Eigenschaften:

```{r, echo=T, collapse=T, comment="#>"}
# Modus bzw. Struktur (mode) - Was ist es?
typeof(x)

# Länge - Wie viele Elemente?
length(x)

# Attribute - Zusätzliche Informationen (Metadaten)
attributes(x) # x wurden noch keine attribute zugeordnet

# ------ Zusatz ------

# Objektbestimmung
class(x)
```

Nun wollen wir auf die einzelnen Elemente in den Vektoren zugreifen (indizieren). Wir können die einzelnen Elemente eines Vektor mit `[]` anwählen (`subsetting`).

```{r, echo=T, collapse=T, comment="#>"}
zahlenreihe <- c(1, 2.5, 3, 4, 5.77, 6, 7)

# Das erste Element
zahlenreihe[1]

# das fünfte Element
zahlenreihe[5]

# Das letzte Element
zahlenreihe[length(zahlenreihe)]

# Mit - (Minus) können wir gezielt Elemente ausschließen
zahlenreihe[-4]

# Wir können auch Sequenzen auswählen
zahlenreihe[2:5]

# Wir können auch gezielt mehrere Elemente ausschließen oder auswählen
zahlenreihe[-c(1, 4)]

zahlenreihe[c(1, 2, 5)]

# Das Gleiche funktioniert auch mit einem character vector

buchstabenreihe <- c("A", "B", "C", "D", "E")

buchstabenreihe[1]
```

### Faktoren (factor)

* Faktoren  → nominale/ordinale Variablen
  * nominale Variable
  * Kategorien des Faktors = levels (kann Zahlen oder Buchstaben enthalten)

Bisher haben wir `numeric`, `character` und `logical` Vektoren kennengelernt. Ein weiterer Objekttyp wird benötigt, um kategoriale Daten oder Gruppierungsvariablen darzustellen. Dieser Objekttyp wird `factor` genannt. 

Ein `Faktor` ist ein Vektor mit ganze Zahlen (`integer`), welcher eine Beschriftung für die einzelnen Fakttorstufen (`levels`) besitzt. Die Beschriftungen sind letztlich Attribute (`attributes`), die Informationen über die Faktorstufen geben. Ein Beispiel:

```{r, echo=T, collapse=T, comment="#>"}
# Geschlecht als character vector
sex <- c("Mann", "Frau", "Mann", "Frau", "Frau", "Div")
sex

# Modus (mode)
typeof(sex)

# Attribute
attributes(sex)
```

Nun haben wir einen `character vector` mit Informationen über Geschlechter. In einem nächsten Schritt wollen wir diesen Vektor als Faktor definieren.

```{r, echo=T, collapse=T, comment="#>"}
# Geschlecht als Faktor
sexf <- factor(sex, levels = c("Mann", "Frau", "Div"))
sexf

# Geschlecht hat nun den Datentyp integer
typeof(sexf)

# und die Klasse "factor"
class(sexf)

# jetzt sind auch die Attribute definiert
attributes(sexf)
```

Wir haben bei der Definition die `levels` explizit angegeben. Das hätten wir aber nicht machen müssen. R ordnet standardmäßig alle Faktorstufen alphabetisch zu. 

```{r, echo=T, collapse=T, comment="#>"}
# Geschlecht als Faktor
sexf2 <- factor(sex)
sexf2

# Datentyp
typeof(sexf2)

# Klasse
class(sexf2)

# Attribute 
attributes(sexf2)
```

Wir werden Faktoren später häufig bei der Modellierung benötigen z.B. bei Regressionsmodellen mit Dummyvariablen. Die erste Stufe eines Faktors wird von R automatisch als Referenzkategorie bestimmt, wenn wir den Faktor als Prädiktorvariable in das Modell einbringen. Manchmal wollen wir jedoch eine andere Stufe als Referenzkategorie. In diesem Fall kann man die Reihenfolge der Faktorstufen ändern.

Über `relevel()` kann die Refrenzkategorie bestimmt werden.

```{r, echo=T, collapse=T, comment="#>"}
# Unsere Refrenzkategorie ist gegenwärtig "Mann"
levels(sexf)

# Wir ändern die Refrenkategorie folgend auf "Frau"
sexf <- relevel(sexf, ref = "Frau")
levels(sexf)
```

Mit der Funktion `factor()` lassen sich alle Faktorstufen frei ordnen, solange wir im Befehl alle Faktorstufen benutzen. Die erste Stufe wird folglich zur Refrenzkategorie.

```{r, echo=T, collapse=T, comment="#>"}
# Unsere Refrenzkategorie ist gegenwärtig "Mann"
levels(sexf)

# Wir ändern die Refrenkategorie folgend auf "Frau"
sexf <- factor(sexf, levels = c("Frau", "Mann", "Div"))
levels(sexf)
```

Durch die Festlegung einer Variable als Faktor wird diese automatisch dummykodiert und kann umstandslos in ein Modell einbezogen werden. Wir müssen nur die Refrenzkategorie im Blick behalten.

### Datensatz (data frame)

* Datensatz (mehrere Zeilen und Spalten) 
  * Spalten (Vektoren und Faktoren)
  * Zeilen (Fälle, z. B. Versuchspersonen)
  
Nun kommen wir zu dem für uns wichtigsten Objekt in R, dem Datensatz. Ein Datensatz besteht aus Zeilen (rows) und Spalten (columns) **gleicher Länge** und entspricht einem Datensatz in SPSS. 

Die Spalten eines Datensatz sind lediglich Vektoren. Sie können damit `numeric`, `character` und `logical` sein, oder als Faktor auftreten. Numerische Variablen in einem Datensatz sollten demzufolge numerische Vektoren und kategoriale Variablen/Gruppierungsvariablen sollten Faktoren sein. 

Datensätze werden traditionell über die Funktion `data.frame()` definiert. Da wir das *tidyverse* nutzen, greifen wir auf eine weiterentwickelte Form zurück - `tibbles` oder `tbl`. tibbles werden über die Funktion `tibble()` definiert und erleichtern so die Arbeit mit dem Datensatz. 

**Anmerkung:** Der Vorteil liegt beim Einlesen von Datensätzen, da weniger Rücksicht auf die Datenstruktur genommen werden muss. Durch `tibbles` wird viel durch R automatisiert.

Erstellung eines Datensatz.

```{r, include=F}
library(tidyverse)
```


```{r, echo=T, collapse=T, comment="#>"}
# Vektoren
sex <- factor(c("Mann", "Frau", "Mann", "Mann", "Frau", "Mann"))
alter <- c(22, 45, 67, 87, 16, 56)

# Datensatz
datensatz <- tibble(sex, alter)
datensatz

```

Unser `datensatz` ist damit ein Datensatz mit zwei Variablen (`sex` und `alter`) und sechs Fällen (rows). Dieser wird uns entsprechend im `Environment` angezeigt.

Ein Datensatz hat die Attribute `names()`, `colnames()` und `rownames()`  (`names()` und `colnames()` bedeuten dasselbe).

```{r, echo=T, collapse=T, comment="#>"}
attributes(datensatz)
```

Wir können zudem sowohl die Länge des Spaltenvektors (Anzahl der Spalten) über `ncol` abfragen, wie auch die Länge des Zeilenvektors (Anzahl der Fälle) über `nrow`. 

```{r, echo=T, collapse=T, comment="#>"}
ncol(datensatz)

nrow(datensatz)
```

#### Datensatz indizieren (subsetting)

Ein Datensatz ist eine 2-dimensionale Struktur aus Spalten und Fällen, die entsprechend indiziert werden kann.

* Einzelne Spalten können über `$` ausgewählt werden.
* Einzelne oder mehrere Elemente, ob Spalten oder Zeilen, können über `[]` ausgewählt werden.

```{r, echo=T, collapse=T, comment="#>"}
# Spaltenname zur Auswahl einer spezifischen Variable über $
datensatz$sex
datensatz$alter

# Spaltenname zur Auswahl einer spazifischen Variable über []
datensatz["sex"]
datensatz["alter"]

# Nach Position auswählen
datensatz[1]
datensatz[2]
```

Wir können aber auch mehrer Variablen und sogar Zeilen (Fälle) auswählen.

```{r, echo=T, collapse=T, comment="#>"}
# Erste Spalte und erste Zeile
datensatz[1, 1]

# Erster Fall über alle Spalten (Variablen)
datensatz[1, ]

# Alle Zeilen in der ersten Spalte
datensatz[, 1]

# Wir können auch Sequenzen benutzen
# Ersten drei Fälle über alle Spalten
datensatz[1:3, ]

# Da die Spalten Vektoren sind, können wir diese genauso indizieren
# Erster Fall im Vektor zu Geschlecht
datensatz$sex[1]
          
# Letzten drei Fälle in der Variable alter
datensatz$alter[4:length(datensatz$alter)]

# Die Spalten sex und alter
datensatz[c("sex", "alter")]
```

**Damit haben wir die wichtigsten Objekte und Datentypen kennengelernt! Nun können Sie entweder im nächsten Kapitel mit dem Einlesen von Datensätzen und der Datentransformation weitermachen, oder Sie vertiefen Ihr wissen zu Datentypen über die folgenden Absätze zu Listen und Matrizen, sowie den Regeln der Vektorisierung in R.** 

### Listen (list)

In Arbeit!

