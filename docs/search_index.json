[["index.html", "R Workshop - Sozialwissenschaften Vorwort 0.1 Voraussetzungen 0.2 Warum R? 0.3 Was ist R? 0.4 Aller Einstieg ist schwer?! 0.5 Typographie 0.6 Weiterführende Literatur", " R Workshop - Sozialwissenschaften Yannick Diehl und Daniel Moosdorf 2021-05-16 Vorwort Dieser Workshop richtet sich insbesondere an Studierende der Sozialwissenschaften und möchte einen einfachen und verständlichen Einstieg in statistische Auswertungen mit R bieten. Ein besonderer Augenmerk liegt auf Anwender:innen die eine neue Heimat zur Lösung statistischer Aufgaben- und Problemstellungen suchen und folgend Kenntnisse im Umgang mit (u.a. kommerziellen) Statistik- und Analyse-Software besitzen (v.a. SPSS). Anwendungsziel der kommenden Analysetechniken sind insbesondere sozialwissenschaftliche Studien/Bevölkerungsumfragen mit wissenschaftlichen Erhebungsstandards, wenngleich auch “unstandartisierte” Datensätze mit den vorzustellenden Techniken verarbeitet werden können. Zudem soll den künftigen Anwender:innen eine umfassende Funktionsbibliothek an die Hand gegeben werden, welche eine komplexe Gewichtung von Studiendaten erlaubt. 0.1 Voraussetzungen Bitte installieren Sie hierfür die aktuelle Version von R unter: R Programm - Version 4.0.4 (02.05.2021) Darüber hinaus werden wir mit der integrierten Entwicklungsumgebung (IDE) RStudio arbeiten. Die aktuelle Version findet sich unter: RStudio Desktop Intergrierte Entwicklungsumgebungen wie RStudio vereinfachen den Arbeitprozess mit der Programmiersprache R ungemein, wenngleich auch schon im ersten Installationsschritt über das R Programm die gleichen Funktionsanwendungen ausführbar sind. So stellt RStudio vor allem eine Vereinfachung des Arbeitsprozesses dar, obgleich mit weitreichenden Implikationen bei der Nachvollziehbarkeit von Ablaufschritten und Anwendungsverfahren. 0.2 Warum R? R ist eine Programmiersprache, die speziell für statistische Berechnungen und Visualisierungen von Daten konzipiert ist. R ist eine der führenden Lösungen für die statistische Datenanalyse und kann auch für das Data Mining oder Predictive Analytics eingesetzt werden. Daten lassen sich mit der Sprache sehr flexibel auswerten und visualisieren. Sowohl wissenschaftliche Organisationen als auch große Unternehmen wie Oracle oder Microsoft verwenden R umfassend. R kann problemlos in alle Ebenen der Analyse und Präsentation von Daten integriert werden. Dank der Flexibilität von R ist der gleiche Code sowohl für kleinere Datenanalysen als auch für umfangreiches Data Mining im Big-Data-Umfeld geeignet. Die Plattformunabhängigkeit sorgt dafür, dass R in verschiedenste IT-Strukturen leicht integrierbar und universell nutzbar ist. Und zuletzt: Im Gegensatz zu anderen Lösungen für die Analyse und Visualisierung von Daten ist R Open Source. Es fallen keine Lizenzkosten an, auch nicht für den Großteil der verfügbaren Erweiterungspakete. 0.3 Was ist R? R wurde 1992 von Ross Ihaka und Robert Gentleman an der Universität Auckland entwickelt und wird als Open Source-Software unter der GNU General Public License durch die in Wien ansässige R Foundation for Statistical Computing verwaltet und verbreitet. R stammt direkt von der kommerziellen statistischen Programmiersprache S ab und während das Herz von R durch das R (Development) Core Team (aus dem auch die Stiftung hervorgegangen ist) weiterentwickelt wird, liegt die eigentliche Stärke von R in der Verfügbarkeit von Zusatzfunktionen, in Form sogenannter Packages (dt. Packete). So erweitern unabhängige Entwickler überall auf der Welt durch unzählige Packages mit unterschiedlichsten Ausrichtungen die Funktionsmöglichkeit von R, angefangen von der klassichen Regression bis zum maschinellen Lernen. Mehr als 12.000 dieser Funktionspakete, die geschätzt mehr als 220.000 Funktionen beinhalten, stehen über das Comprehensive R Archive Network (CRAN) und einige weitere Hubs zur kostenfreien Verfügung. Folglich gibt es praktisch kein statistisches Problem, dass noch nicht eine entsprechende Lösung in R gefunden hat und damit gebrauchsfertig heruntergeladen und nach eigenen Vorstellungen modifiziert werden kann. 0.4 Aller Einstieg ist schwer?! Wir werden uns primär mit R als Statistikumgebung und weniger als klassische Programmierumgebung beschäftigen, wenngleich kleinere Exkurse in die Fundamente dieser Sprache nicht vermieden werden können. Unser Anspruch bleibt dabei immer eine einfache, konsistente und übersichtliche Lösung zu geben, um dem freien und selbstbestimmten Lernen und Arbeiten aller Teilnehmenden Sorge zu tragen. Um diesem Anspruch gerecht werden zu können, werden wir uns vornehmlich in relativ “abgeschlossenen” Ökosystemen (Ecosystems) bewegen, also Sammlungen von Packeten, die aufeinander abgestimmt wurden. Das bekannteste Beispiel ist hierfür sicherlich das tidyverse, welches maßgebend von einem der großen R-Pioniere und RStudio chief scientist Hadley Wickham entwickelt wurde. Auf Grundlage des selbigen werden wir noch die Packete von Daniel Lüdecke strengejacke und die beeindruckenden Modellaufbereitungen in easystats kennen lernen. So repräsentieren diese Packete in vollem Umfang den “state-of-the-art” sozialwissenschaftlicher Datenanalysetechniken, obgleich der Lernprozess damit deutlich vereinfacht ist. Zudem werden alle genannten Packete, vor allem das tidyverse, auch in nicht-universitären Kontexten weitreichend genutzt. 0.5 Typographie Die folgenden Kapitel bestehen zu einem großen Teil aus R Code und damit aus den entsprechenden chunks. Damit können sie leicht erkannt und für den eigenen Gebrauch in das persönliche R Script kopiert werden. Ein Beispiel: x &lt;- seq(from = 1, to = 100, by = 10) x Das Ergebnis lässt sich folgend in der Konsole ablesen. ## [1] 1 11 21 31 41 51 61 71 81 91 Damit ist x unser Input und ## [1] 1 11 21 31 41 51 61 71 81 91 unser Output nachdem wir x eine Zahlensequenz zwischen 1 und 100 in 10er Schritten zugewiesen haben. 0.6 Weiterführende Literatur Wir orientieren uns vor allem in den ersten beiden Kapiteln unseres Workshops an dem Kurs: Einführung in R von Andrew Ellis und Boris Mayer. Grundständige Literatur, die auch zu diesem Workshop passt, findet sich als freie Publikation von Garrett Grolemund und Hadley Wickham unter dem Titel R for Data Science. Zur Vertiefung bieten sich die Bücher Hands-On Programming with R von Garrett Grolemund und Advanced R von Hadley Wickham an. "],["rstudio.html", "1 RStudio 1.1 Benutzeroberfläche 1.2 Optionen 1.3 Die Konsole 1.4 Das Environment und History 1.5 Files 1.6 Packages (Packete) 1.7 Help 1.8 Arbeiten mit RStudio", " 1 RStudio In einem ersten Schritt wollen wir uns RStudio genauer ansehen. Öffnen Sie nun bitte RStudio. 1.1 Benutzeroberfläche Sie sollten ungefähr die gleiche Benutzeroberfläche bzw. GUI (Graphical User Interface) vor sich sehen (standardmäßig weiß): 1.2 Optionen Wir empfehlen eindrücklich vor Beginn einer intensiven Nutzung mit RStudio die folgenden Punkte in den Optionen unter Preferencesbzw. Global Options zu deaktivieren. Restore .RData into workspace at startup (deaktivieren) Save workspace to .RData on exit (Never) Folgend müssen wir immer alle Daten und Variablen bei einem Neustart von RStudio neu laden. Belohnt werden wir hingegen durch einen frischen Workspace. Sofern Sie Interesse an einer Änderungen der grafischen Darstellung von RStudio haben (z.B. eine dunkle Farbgebung), sollten Sie sich unter dem Menüpunkt Appearance ausprobieren. 1.3 Die Konsole Die R Konsole ist praktisch das Herzstück der Benutzeroberfläche und ermöglicht geschriebenen Code direkt oder über das R Script interpretieren zu lassen. Das &gt; Zeichen ist die R Prompt (das Aufforderungszeichen). Die Konsole kann gerne auch als Übungsfeld für die ersten Eingaben genutzt werden, z.B. als Taschenrechner. 2+3 ## [1] 5 1.4 Das Environment und History Im Reiter Enironment finden wir die Funktion Global Environment (drop-down menu). In diesem Bereich werden alle Objekte, also Variablen und Datensätze, die wir zuvor angelegt haben, gespeichert. Auch selbstgeschriebene Funktionen werden hier hinterlegt. Unter dem Reiter History finden Sie alle Befehle, die Sie bisher ausgeführt haben. Mit einem Doppelklick werden diese automatisch in die Konsole kopiert. Damit können sie einfach modifiziert und/oder erneut ausgebenen werden. Tipp: Die History lässt sich auch direkt über die Testenbefehle cmd+ up auf macOS bzw. strg+ up bei Windows in der Konsole abrufen. 1.5 Files Unter dem Reiter Files können Sie auf Ihre Datenstruktur zugreifen und damit ein Arbeitsverzeichnis (working directory) festlegen (siehe Bild). Die Festlegung eines Arbeitsverzeichnis erleichtert in Folge das Einlesen von weiteren Datenobjekten (z.B. Datensätzen), sofern nicht in einem Project gearbeitet wird. 1.6 Packages (Packete) R stellt uns über base R schon eine ganze Reihe nützlicher Funktionen zur Verfügung. Dieser bewegen sich jedoch auf sehr abstarktem Niveau und würden bei ausschließlicher Nutzung viele Analyseschritte sehr aufwendig machen. Folgend greifen wir auf die versprochenen Packete bzw. Ökosysteme zurück, um unsere Funktionsbibliothek deutlich zu erweitern. Packete lassen sich mit dem folgenden Befehl in der Konsole sehr leicht installieren. install.packages(&quot;tidyverse&quot;) Damit haben wir alle Packete und Funktionen aus dem tidyverse installiert. Nun wollen wir noch strengejacke und easystats installieren. Die Packete aus strengejacke können entweder einzeln über das CRAN installiert werden, oder im Bündel über Github. Wollen wir z.B. nur das Packet sjmisc aus strengejacke installieren verwenden wir den folgenden Befehl: install.packages(&quot;sjmisc&quot;) Sofern das ganze Bündel installiert werden soll, laden wir zunächst das Packet remotes, um Github als Downloadplattform anwählen zu können und dann strengejacke. install.packages(&quot;remotes&quot;) remotes::install_github(&quot;strengejacke/strengejacke&quot;) Damit wurde strengejacke erfolgreich installiert! Das Ökosystem easystats ist gegenwärtig noch in der Testphase und damit auch nur über Github zu laden. install.packages(&quot;remotes&quot;) remotes::install_github(&quot;easystats/easystats&quot;) Gratulation, damit haben wir die wichtigsten Packete installiert! Nun müssen wir sie nur noch aktivieren. Dafür nutzen wir den Befehl library, um auf unsere Funktionsbibliothek zuzugreifen. library(tidyverse) library(strengejacke) library(&quot;easystats&quot;) Wichtig! Das Packetbündel easystats muss beim Aufruf in Anführungszeichen geschrieben werden. Als Alternative können wir Packete auch über den Reiter Packages installieren und aktivieren. Updates lassen sich über den Reiter Packages oder den folgenden Befehl machen: update.packages() bzw. update.pachakes(ask = F) 1.7 Help Selbst wenn man täglich mit R arbeitet, ist es (fast) unmöglich, sich alle Funktionen zu merken. Deshalb bietet R über den Reiter Help die Möglichkeit eine lexikale Darstellung aller Funktionen und Anwendungsmöglichkeiten zu bekommen. Leider sind viele der Einträge zu Beginn nicht ganz leicht verständlich. Nach einiger Zeit bieten sie aber eine zuverlässige Möglichkeit neue Funktionen zu erlenen und alte nachzuschlagen. Hat man eine Funktion im Kopf lässt sich diese leicht über das Suchfenster im Help Viewer suchen. Über die Konsole geht das natürlich auch. Der Befehl hier z.B. für den gewichteten Mittelwert: ?weighted_mean Hier muss nur die gesuchte Funktion hinter ein ? geschrieben werden. Will man herausfinden, welche Funktionen in einem Packet enthalten sind, ist der Reiter Packages zu öffnen. Über das Suchfenster das entsprechende Packet suchen und mit einem Klick öffnen. Anschließend wird man im Help Viewer über die möglichen Funktionen in einer Auswahl informiert. Viele Entwickler erstellen zudem eigene Websites für ihre Packages. Hier einige Beispiele: Auf der Seite des tidyverse das gewünschte Packet aussuchen und dann über Reference eine Auswahlliste der Funktionen aufrufen. Beim Klick auf eine Funktion wird die dahinterliegende Vignette - Erklärung mit Beispielen - geöffnet. Die Packete von strengejacke haben keine gebündelte Auswahl. Wir müssen uns also zuerst eines der Packete aussuchen (sjmisc, sjlabelled, sjplot, sjstats) und dann nach diesem suchen. Bei strengejacke lassen sich alle Packete über den folgenden Link öffnen: https://strengejacke.github.io/*Packetname*/, also z.B. https://strengejacke.github.io/sjmisc/ Bei den Packeten von easystats gilt das genauso. Erst ein Packet wählen (parameters, performance, effectsize, correlation, see) und dann öffnen über: https://easystats.github.io/*Packetname*/ Um einen erster Eindruck über die Anwendungsmöglichkeiten und die Form der Packete zu bekommen, lohnt sich zudem der Klick auf den Reiter Articles auf den Dokumentationsseiten der Packete! Abschließend ist noch die FAQ-Seite Stackoverflow zu empfehlen, auf der schier zu jedem Problem schon einmal eine Frage gestellt und diese beantwortet wurde. Hierzu lohnt es sich das eigene Problem mit dem zusätzlichen Schlagwort Stackoverflow in eine Suchmaschine zu geben und die Einträge nach Lösungen zu durchsuchen. 1.8 Arbeiten mit RStudio Auf an die praktische Arbeit mit R! 1.8.1 Projects (Projekte) Vor der eigentlichen Arbeit mit R und der Analyse von Daten ist es immer ratsam über die Erstellung eines Projekts nachzudenken. Über den Menüpunkt File + New Project + New Directory + New Project öffnet sich die entsprechende Auswahlmaske. Hier kann ein Projektname und der gewünschte Speicherort festgelegt werden. Im nächsten Schritt schieben wir die gewünschten Datensätze in den Projektordner, um einen ungehinderten Datenzugriff zu ermöglichen. Vorteile: Alle Files werden beim Start des Projekts, über den blauen Projektwürfel (.Rproj), wieder geöffnet. Es lassen sich beliebig viele Projekte gleichzeitig öffnen und zwischen diesen wechseln. Bei der Erstellung eines Projekts wird automatisch ein Arbeitsverzeichnis erstellt, auf das zurückgegriffen wird (Projektordner). Man muss sich also nicht mehr um das working directory bemühen und kann z.B. Daten- oder Skriptdateien direkt vom Projektordner aus aufrufen, ohne jedes Mal den vollständigen Pfad definieren zu müssen. 1.8.2 Konsole oder RScript? Es stehen dem Benutzer von RStudio wesentlich zwei Nutzungswege zur Verfügung: 1. Befehle direkt über die Konsole eintippen Die Eingabe über die Konsole ist dann empfehlenswert, wenn man schnell etwas ausprobieren möchte, oder ein Befehl wiederholt werden soll. Die Konsole wird auch bei unvollständiger Eingabe von Funktionen relevant. Im folgenden Beispiel wurde eine Klammer am Ende der Funktion vergessen. &gt; seq(1, 100, 5 + Nun muss entweder die fehlende Klammer zur Vervollständigung eingetippt, oder über Escder Befehl abgebrochen werden. Wird ein Befehl ungewollt ausgeführt, oder ist R abgestürzt? Hier kann ganz leicht über Session + Interrupt R bzw. das rote Stoppschild über der Konsole der Befehl abgebrochen, oder die ganze Sitzung über Session + Terminate R neu gestartet werden. 2. Befehle im Script speichern (vergleichbar mit Syntax aus SPSS) Zur Erstellung eines RScript öffnen wir über das Symbol mit dem weißen Blatt und grünem Kreuz (oben links) ein neues RScript (Tastenkürzel: cmd bzw. strg + up + N). Vorteile sind hier, wie auch in SPSS, die Möglichkeit zur übersichtlichen und nachvollziehbaren Arbeitsweise und das Speichern von Auswertungen. Wichtig! RScript-Datein werden beim Ausführen von oben nach unten gelesen. Wir können also Werte im Laufe eines Scripts immer wieder überschreiben und neu zuweisen. Wir probieren uns zu Beginn wieder an einer kurzen Rechnung aus. 2+3 Um die entsprechende Zeile auszuführen, klicken wir auf Run (Tastenkürzel: cmd bzw. strg + enter). ## [1] 5 Der Output erscheint wie gewohnt in der Konsole. Im nächsten Schritt definieren wir das Ergebnis unserer mathematischen Operation als Variable (Objekt), um es für folgende Anwendungen nutzen zu können. x &lt;- 2+3 Damit haben wir unsere gewünschte Variable (Objekt) mit der Bezichnung x definiert. Wichtig ist für uns erstmal, dass wir unsere definierten Variablen im Environment sehen können. x wird folgend mit dem Wert 5 angezeigt. 1.8.3 Tab completion RStudio verfügt über eine weitere sehr hilfreiche Funktion: Tab completion. Während der Eingabe eines beliebigen Befehls erscheint über RStudio ein entsprechendes Menu mit Befehlsvorschlägen zur Vervollständigung. So erscheint z.B. bei der Eingabe von weighted_mean() eine ganze Reihe von Vorschlägen. Manuell wird auch über Tab das gleiche Menu aufgerufen. Wollen wir die erste Funktion übernehmen, drücken wir Enter zur Bestätigung. Zur Auswahl einer anderen Funktion einfach über die Pfeiltasten die richtige Funktion ansteuern und diese über Enter anwählen. Hat man eine Funktion eingegeben und drückt man innerhalb der Klammern Tab, erscheint eine Liste mit allen Argumenten dieser Funktion. Funktionsargumente definieren welche Daten einbezogen werden sollen und wie mit diesen umgegangen wird. x = steht z.B. für die eingehenden Daten und weights = für das anzuwendende Gewicht. Überschneiden sich zwei Funktionensbezeichungen zwischen zwei Packeten oder wissen wir, dass eine Funktion in einem Packet enthalten ist, können wir auch über den Packetnamen gefolgt von :: eine Funktionsliste erzeugen. 1.8.4 Nützliche Tastenbefehle (Shortcuts) Folgende Tastenbefehle erleichtern das Arbeiten mit R: Wir haben schon folgende Befehle kennen gelernt: cmd bzw. strg + up &gt; Vorherige Befehle in der Konsole anzeigen cmd bzw. strg + up + N &gt; Neues Script erstellen cmd bzw. strg + Enter &gt; Eingabe ausführen Weitere nützliche Befehle: cmd bzw. strg + up + Enter &gt; Gesamtes Script ausführen cmd bzw. strg + up + R &gt; Kapitel im RScript definieren cmd bzw. strg + up + C &gt; Kommentar control bzw. strg + L &gt; Konsole leeren cmd bzw. strg + up + A &gt; Code restrukturieren Für folgende Kapitel: option + - &gt; Zuweisungspfeil (-&gt;) erzeugen cmd bzw. strg + up + M &gt; %&lt;% erstellen "],["programmiersprache-r.html", "2 Programmiersprache R 2.1 Variablen definieren 2.2 Funktionen aufrufen 2.3 Objekte und Datentypen", " 2 Programmiersprache R In diesem Kapitel wollen wir R als Programmierspache kennenlernen. 2.1 Variablen definieren In einem ersten Schritt wollen wir eine Rechnung (einen Wert) in einer Variable speichern. x &lt;- 2*4 Unsere Variable mit dem Namen x (immer links in der Zeile) wird über den Zuweisungspfeil &lt;- (Tastenkürzel: option + -) mit dem Ergebnis aus 2*4 (8) definiert. Zur Kontrolle können wir x mit den folgenden Befehlen aufrufen. x ## [1] 8 Man kann auch gleich bei der Definition der Variablen die Zuweisung in Klammern schreiben und das Resultat wird gleichzeitig in der Konsole angezeigt: (x &lt;- 2*4) ## [1] 8 Tipp: Sollten Sie aus anderen Programmiersprachen schon Kenntnisse mitbringen und = als Zuweisungsoperator kennen, empfehlen wir dennoch eindringlich mit &lt;- zu arbeiten. Funktionen in R arbeiten bei der Zuweisung von Argumenten mit dem Zuweisungsoperator =. Folglich ist die Verwendung von &lt;- nicht nur besser zu lesen, sie kann auch Fehler vorbeugen. 2.1.1 Variablennamen Eine Variable muss immer einen Namen haben. Sie darf aus Buchstaben, Zahlen und den Zeichen . und _ bestehen. Dennoch muss sie immer mit einem Buchstaben beginnen und darf keine Leerzeichen enthalten. Um einen gut lesbaren und verständlichen Code zu schreiben, gibt es ein paar Konventionen an die man sich halten sollte. Hier gibt es zwei gängige Möglichkeiten und eine ältere Form um Variablen zu bennen. Die Wahl ist egal, solange man konsequent bei einer Schreibweise bleibt! 1. snake_case_variable Bei dieser Schreibform werden die einzelnen Worten in einer Variablenbezeichnung durch Unterstriche verbunden und alle Worte kleingeschrieben. 2. camelCaseVariable Hier wird nur das erste Wort kleingeschrieben und die folgenden mit dem ersten Buchstaben großgeschrieben. 3. variable.with.perdiods (alt) Die kleingeschriebenen Worte werden mit Punkten getrennt. # Gute Bezeichnungen efaKonstrukt1 efa_konstrukt_1 # Schlechte Bezeichnungen Efa.konstrukt_1 efaKonstrukt_1 # Unmöglich efa 1 2.2 Funktionen aufrufen “Everything that exists is an object. Everything that happens is a function call.” –John Chambers Objekte haben wir schon in ihrer einfachsten Form als Variable kennengelernt. Nun wollen wir uns den Funktionen (function calls) in R zuwenden. Wir wollen uns eine Funktion an einem fiktionalen Beispiel einmal ansehen. Unsere Funktion sieht wie folgt aus: functionName(arg1 = Daten, arg2 = option1, arg3) In einem ersten Schritt sehen wir uns an, welchen Namen die Funktion trägt. Unsere Funktion heißt functionName. Wir können leider nicht direkt aus dem Namen erschließen, welche Auswirkung unser function call haben wird. In so einem Fall würde ein Blick in Help (?functionName) sicher Abhilfe schaffen, wenngleich wir in unserem Beispiel leider keine Dokumentation nutzen können. So sehen wir uns in einem zweiten Schritt die Argumente unserer Funktion an. Wie wir sehen können, besitzt unsere Funktion drei Argumente: arg1, arg2 und arg3. Die Argumente werden mit spezifischen Werten über = bestückt. In unserem Beispiel benötigt das erste Argument Daten und das zweite Argument einen spezifischen Wert aus einer Auswahl an möglichen Werten - diese werden immer vom Entwickler der Funktion in der Dokumentation angegeben. Das dritte Argument wird als “default” abgerufen, also über eine Voreinstellung der Entwicklers geladen. Argumente die mit “default” arbeiten sind aber keinesfalls fest. Sie können immer auch durch andere Werte ersetzt werden. Argumente arbeiten immer dann mit “default,” wenn die Grundeinstellung des Arguments die häufigste Nutzungsform ist und man nicht bei jedem function call die Wertzuweisung von neuem machen will. Tipp: Wollen wir alle verfügbaren Argumente in einer Funktion sehen, drücken wir Tab. Wichtig! Eine Funktion kann beliebig viele Argumente besitzen. Um uns einer “großen” Funktion zu nähern, müssen wir zu Beginn einige Grundfunktionen kennenlernen. c() &gt; Combine: kreiert einen Vektor (Zahlenfolge) seq(from, to, by) &gt; Generiert eine Sequenz an Zahlen : &gt; Colon Operator: generiert eine reguläre Sequenz (Sequenz in Einerschritten) rep(x, times, each) &gt; Wiederholt x times: Sequent wird n-mal widerholt each: jedes Element wird n-mal wiederholt head(x, n = 6) &gt; Zeigt die n ersten Elemente von x an tail(x, n = 6) &gt; Zeigt die n letzten Elemente von x an print(x) &gt; Gibt Werte eines Objekts aus (vor allem bei großen Objekten wichtig) round(x, digits) &gt; Rundung von Zahlen z.B. c(1, 2, 3, 4, 5) #&gt; [1] 1 2 3 4 5 seq(from = 1, to = 10, by = 2) #&gt; [1] 1 3 5 7 9 1:5 #&gt; [1] 1 2 3 4 5 rep(x = 2, times = 5, each = 3) #&gt; [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 x &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) head(x = x, n = 6) #&gt; [1] 1 2 3 4 5 6 tail(x = x, n = 4) #&gt; [1] 7 8 9 10 print(x = x) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 y &lt;- c(1.222, 2.333, 3.444) round(x = y, digits = 1) #&gt; [1] 1.2 2.3 3.4 Wir wollen uns die Variable y aus unserem Beispiel etwas genauer ansehen. y enthält durch das Aufrufen der Funktion c() einer Reihe an Zahlen (1.222 bis 3.444). y enthält also Zahlen mit drei Nachkommastellen, die wir mit der Funktion round() auf eine Nachkommastelle gerundet werden sollen. Das Argument digits beschreibt damit die Rundungszahl nach dem Komma. Folglich löst der Wert 1 eine Rundung der Nachkommastellen auf eine Nachkommastelle aus. Der Wert im Argument digits kann damit theoretisch von 0 bis ∞ variieren. 2.2.1 Verschachtelung von Funktionen Zudem können wir beliebig viele Funktion ineinander verschachteln, d.h. wir können den Output einer Funktion einer weiteren Funktion als Input übergeben. Wir bilden zuerst einen Vektor, runden die Zahlen und lassen uns dann nur die ersten drei Zahlen ausgeben. x &lt;- c(1.11, 1.22, 1.33, 1.44, 1.55) x &lt;- round(x = x, digits = 1) head(x = x, n = 3) #&gt; [1] 1.1 1.2 1.3 # Jetzt in einer verschachtelten Funktion head(x = round(x = c(1.11, 1.22, 1.33, 1.44, 1.55), digits = 1), n = 3) #&gt; [1] 1.1 1.2 1.3 # In Kurz head(round(c(1.11, 1.22, 1.33, 1.44, 1.55), digits = 1), n = 3) #&gt; [1] 1.1 1.2 1.3 Die Funktionen werden immer in der Reihenfolge von innen nach außen ausgeführt. In unserem Beispiel also erst c(), dann round() und dann head(). Jede Funktion gibt ihren Wert an die nächste Funktion weiter. Anmerkung: Die Funktion head() enthält zwei Argumente mit “default”-Werten: keepnums und addrownums. Beide bekommen automatisch den Wert NULL und müssen damit nicht ausgeschrieben werden. Sie werden für unsere Anwendung der Funktion auch nicht gebraucht und damit nicht angepasst. Vorteile von verschachtelten Funktionen: Es können unendlich viele Funktionen verschachtelt werden. Wir müssen Argumente nicht ausschreiben, solange sie eindeutig von der Funktion erkannt werden können. So gibt es in allen genutzten Funktionen mit x = nur eine Schnittstelle für die Dateneingabe. Weiterhin können wir so unseren Code in eine Kette von Befehlen verwandeln, die nur einen Output (ein Objekt) ausgibt. Die Objektstruktur wird damit übersichtlicher. Nachteil: Wenn wir mehrere Funktionen ineinander verschachteln, kann unser Code schnell unlesbar werden. Natürlich könnten wir die einzelnen Zwischenschritte speichern, wie im Beispiel weiter oben, aber dann definieren wir eine Menge Variablen, welche wir vielleicht gar nicht benötigen. Wir werden im Kapitel über Datentransformation einen neuen Operator kennenlernen, welcher eine sehr elegante Lösung für dieses Problem bietet. 2.3 Objekte und Datentypen In R kann alles als Objekt in Variable gespeichert werden. Anmerkung: Objekte sind nicht gleich Variablen, da Objekte nicht gespeichert werden müssen. Ein Objekt wird erst dann zur Variable, wenn es eine Bezeichnung über &lt;- erhält und damit gespeichert wird. Einzelne Werte / Mehrere Werte (z.B. ein Datensatz mit Rohdaten) Tabellen Statistische Modelle Ergebnisse statitischer Analysen Funktionen, etc. In R gibt es eine Vielzahl von verschiedenen Objekttypen. Die grundlegenden Objekttypen (und deren Gemeinsamkeit mit SPSS-Datentypen) sind: 2.3.1 Vektoren Vektoren → ordinale/metrische Variablen numeric (Zahlen) character (Buchstaben) logical (Richtig oder Falsch) Beispiel # Numerischer Verktor (numeric vector) x &lt;- c(1, 2, 3, 4, 5) x #&gt; [1] 1 2 3 4 5 # Buchstaben Vektor (character vector) y &lt;- c(&quot;Peter&quot;, &quot;Yusuf&quot;, &quot;Sarah&quot;, &quot;Aayana&quot;) y #&gt; [1] &quot;Peter&quot; &quot;Yusuf&quot; &quot;Sarah&quot; &quot;Aayana&quot; # Logischer Vektor (logical vector) z &lt;- c(TRUE, FALSE, T, F, NA) # TRUE/FALSE können mit T/F abgekürzt werden z #&gt; [1] TRUE FALSE TRUE FALSE NA Vektoren stellen die fundamentalen Datentypen dar. Alle weiteren Datentypen bauen auf diesen auf. Wichtig! Vektoren müssen aus denselben Elementen bestehen, d.h. wir können nicht logical und character Vektoren mischen. Sie bilden damit die atomare Struktur in R. numeric vector: Die häufigste Datenform in R. Numerische Vektoren lassen sich zudem weiter unterteilen, in integer (ganze Zahlen) und double (reele Zahlen - Kommazahlen). Zahlen werden in R praktisch immer als double abgelegt (auch die ganzen Zahlen) und müssen somit nie für Berechungen gewandelt werden. character vector: Die Elemente dieses Typs bestehen aus Zeichen, welche von Anführungszeichen umgeben werden (entweder ’ oder \" ). Anmerkung: Anführungszeichen dienen in R zur Kennzeichnung von nicht numerischen Werten. Wir müssen also alle Worte in jedem Kontext in Anführungszeichen schreiben. logical vector: Die Elemente dieses Typs können nur 3 Werte annehmen:TRUE, FALSE oder NA. Anmerkung: NA steht für fehlende Werte. Vektoren haben folgend drei Eigenschaften: # Modus bzw. Struktur (mode) - Was ist es? typeof(x) #&gt; [1] &quot;double&quot; # Länge - Wie viele Elemente? length(x) #&gt; [1] 5 # Attribute - Zusätzliche Informationen (Metadaten) attributes(x) # x wurden bewusst keine Informationen zugeordnet, da wir einen anderen Zugang du Metadaten lernen werden #&gt; NULL # ------ Zusatz ------ # Objektbestimmung class(x) #&gt; [1] &quot;numeric&quot; Nun wollen wir auf die einzelnen Elemente in den Vektoren zugreifen. Wir können die einzelnen Elemente eines Vektor mit [] auswählen (subsetting): zahlenreihe &lt;- c(1, 2.5, 3, 4, 5.77, 6, 7) buchstabenreihe &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;) # Das erste Element zahlenreihe[1] #&gt; [1] 1 buchstabenreihe[1] #&gt; [1] &quot;A&quot; # das fünfte Element zahlenreihe[5] #&gt; [1] 5.77 buchstabenreihe[5] #&gt; [1] &quot;E&quot; # Das letzte Element zahlenreihe[length(zahlenreihe)] #&gt; [1] 7 buchstabenreihe[length(buchstabenreihe)] #&gt; [1] &quot;E&quot; # Mit - (Minus) können wir gezielt Elemente ausschließen zahlenreihe[-4] #&gt; [1] 1.00 2.50 3.00 5.77 6.00 7.00 buchstabenreihe[-4] #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;E&quot; # Wir können auch Sequenzen auswählen zahlenreihe[2:5] #&gt; [1] 2.50 3.00 4.00 5.77 buchstabenreihe[2:5] #&gt; [1] &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; # Wir können auch gezielt mehrere Elemente ausschließen oder auswählen zahlenreihe[-c(1, 4)] #&gt; [1] 2.50 3.00 5.77 6.00 7.00 buchstabenreihe[-c(1, 4)] #&gt; [1] &quot;B&quot; &quot;C&quot; &quot;E&quot; zahlenreihe[c(1, 2, 5)] #&gt; [1] 1.00 2.50 5.77 buchstabenreihe[c(1, 2, 5)] #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;E&quot; 2.3.2 Faktoren Bisher haben wir numeric, logical und character Vektoren kennengelernt. Ein weiterer Objekttyp wird benötigt, um kategoriale Daten oder Gruppierungsvariablen darzustellen. Dieser Objekttyp wird factor genannt. Faktoren → nominale/ordinale Variablen nominale Variable Kategorien des Faktors = levels (kann zahlen oder Buchstaben enthalten) Ein factor ist ein Vektor von natürlichen Zahlen (integer vector), der mit zusätzlicher Information (Metadaten) versehen ist. Diese attributes sind die Objektklasse factor und die Faktorstufen levels. Am besten wir illustrieren dies mit einem Beispiel. "]]
